'use strict';

var create           = Object.create
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , keys             = Object.keys
  , parse            = JSON.parse
  , diff             = require('es5-ext/lib/List/diff').call
  , peek             = require('es5-ext/lib/List/peek').call
  , aritize          = require('es5-ext/lib/Function/aritize').call
  , invoke           = require('es5-ext/lib/Function/invoke')
  , _                = require('es5-ext/lib/Function/i')
  , c                = require('es5-ext/lib/Object/descriptors/c')
  , ce               = aritize(require('es5-ext/lib/Object/descriptors/ce'), 1)
  , e                = require('es5-ext/lib/Object/descriptors/e')
  , v                = require('es5-ext/lib/Object/descriptors/v')
  , oEvery           = require('es5-ext/lib/Object/plain/every').call
  , oForEach         = require('es5-ext/lib/Object/plain/for-each').call
  , values           = require('es5-ext/lib/Object/plain/values').call
  , oMap             = require('es5-ext/lib/Object/plain/map').call
  , isString         = require('es5-ext/lib/String/is-string')
  , ee               = require('event-emitter')
  , filters          = require('./filters')
  , list             = require('./list')
  , relations        = require('./relations')
  , validator        = require('./validator')
  , DependencyError  = require('./dependency-error')

  , buildErrorMsg;

module.exports =  ee(create({}, {
	create: e(function (data, emitter) {
		var created = new Date;
		this.parseDependencies(data);
		return this.validate(data, true) && this.restore(
			this.implementation.generateId(), created, created, data, emitter);
	}),
	validate: v(function (data, all, current) {
		var errors = [], error;
		oForEach(data, function (value, name) {
			if (!this.schema[name]) {
				if (!this.schema.__dynamic) {
					console.log('unrecognized', name, this.schema);
					errors.push(_("Unrecognized property") + " \"" + name + "\"");
				}
			} else if ((error = this.schema[name].validate(value, data, current))) {
				console.log('INVALID', name, error);
				errors.push(error);
			}
		}, this);
		if (all) {
			diff(keys(this.schema), keys(data)).forEach(function (name) {
				if ((error = this.schema[name].validate(null, data, current))) {
					console.log('EMPTY', name, error);
					errors.push(error);
				}
			}, this);
		}
		if (errors.length) {
			console.log("ERRONEUS DATA", data);
			throw new Error(errors.join("\n"));
		}
		return true;
	}),
	normalize: v(function (data, all, current) {
		var error;
		oForEach(data, function (value, name) {
			if (!this.schema[name]) {
				if (!this.schema.__dynamic) {
					// console.warn('Unrecognized property:', name, data[name], current && current._id, data);
					delete data[name];
				}
			} else if ((error = this.schema[name].validate(value, data, current))) {
				if (!isString(this.schema[name].type)) {
					throw new Error(error);
				}
				// console.warn('Invalid value for', name, ': \'' + data[name] + '\' |', error, current && current._id, data);
				data[name] = null;
			}
		}, this);
		if (all) {
			diff(keys(this.schema), keys(data)).forEach(function (name) {
				if ((error = this.schema[name].validate(null, data, current))) {
					if (!isString(this.schema[name].type)) {
						throw new Error(error);
					}
					// console.warn('Missing value for', name, error, current && current._id, data);
				}
			}, this);
		}
		return true;
	}),
	parseDependencies: v((function (resolve) {
		return function (content) {
			keys(this.foreigns).forEach(resolve.bind(content, this));
		};
	}(function (ns, name) {
		var obj, id;
		if (this[name] && !this[name]._id) {
			obj = ns.schema[name].type[id = this[name]];
			if (!obj) {
				throw new DependencyError(id, this, name, ns.schema[name].type);
			}
			this[name] = obj;
		}
	}))),
	restore: e(function self (id, created, updated, data, emitter) {
		var obj = this[id] || this.waste[id];
		// console.log('restore', id, updated, obj && obj._updated);
		if (obj) {
			if (created.getTime() !== obj._created.getTime()) {
				throw new Error("Tried to restore previously created object "
					+ "with different meta data");
			} else if (updated <= obj._updated) {
				return obj;
			}
			if (obj._destroyed) {
				obj = null;
			}
		}
		this.parseDependencies(data);
		if (obj) {
			return obj._reset(data, emitter, updated);
		}
		this.normalize(data, true);
		this[id] = obj = defineProperties(create(this.data, {
			_id: v(id),
			_ns: v(this),
			_created: v(created),
			_updated: c(updated)
		}), oMap(data, ce));
		delete this.waste[id];
		obj._on('destroy', this.onObjectDestroy);
		obj._on('update', this.onObjectUpdate);
		defineProperty(this, 'length', c(this.length + 1));
		this.emit(emitter, 'update', obj, null, emitter);
		this.emit(emitter, 'add', obj, emitter);
		return obj;
	}),
	onObjectDestroy: v(function (old, obj, emitter) {
		delete this[obj._id];
		this.waste[obj._id] = obj;
		defineProperty(this, 'length', c(this.length - 1));
		this.emit(emitter, 'update', obj, old, emitter);
		this.emit(emitter, 'remove', obj, old, emitter);
	}),
	onObjectUpdate: v(function (changed, old, obj, emitter) {
		this.emit(emitter, 'update', obj, old, emitter);
	}),
	createRelation: v(function (ns, name) {
		var rel = this.relations[ns.id] || (this.relations[ns.id] = {});
		if (rel.hasOwnProperty(name)) {
			throw new Error("Relation already created");
		}
		rel = (rel[name] = create(relations, {
			from: v(this),
			to: v(ns),
			name: v(name)
		}));
		defineProperties(rel, {
			onToUpdate: v(rel.onToUpdate.bind(rel)),
			onToDestroy: v(rel.onToDestroy.bind(rel)),
			onFromDestroy: v(rel.onFromDestroy.bind(rel)),
			onadd: v(rel.onadd.bind(rel))
		});
		ns.on('add', rel.onadd);
		values(ns).forEach(rel.onadd);
	}),
	getRelation: v(function (ns, name) {
		var rel, k;
		if ((rel = this.relations[ns.id])) {
			if (name) {
				rel = rel[name];
			} else if ((k = keys(rel)).length > 1) {
				throw new Error("There are many relations for this namespace, "
					+ "please provide relation name");
			} else {
				rel = rel[k[0]];
			}
		}
		if (!rel) {
			throw new Error("No relations were configured for given namespace");
		}
		return rel;
	}),
	serialize: e(function () {
		return values(this).map(invoke('_serialize'));
	}),
	list: e(function (sortMethod) {
		var index, l;
		if ((index = this.lists.methods.indexOf(sortMethod)) !== -1) {
			return this.lists.lists[index];
		}
		l = list(this, sortMethod);
		this.lists.methods.push(sortMethod);
		this.lists.lists.push(l);
		return l;
	}),
	filter: e(function (name, cond) {
		if (!this.filters) {
			defineProperty(this, 'filters', v(filters(this, this)));
		}
		return this.filters.filter(name, cond);
	})
}), true);
