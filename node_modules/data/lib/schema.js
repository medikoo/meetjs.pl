'use strict';

var isArray          = Array.isArray
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , stringify        = JSON.stringify
  , dateFormat       = require('es5-ext/lib/Date/format')('%Y-%m-%d').call
  , datetimeFormat   = require('es5-ext/lib/Date/format')('%Y-%m-%d %H:%M').call
  , timeFormat       = require('es5-ext/lib/Date/format')('%H:%M').call
  , i                = require('es5-ext/lib/Function/i')
  , memoize          = require('es5-ext/lib/Function/memoize')
  , contains         = require('es5-ext/lib/List/contains').call
  , forEach          = require('es5-ext/lib/List/for-each/call')
  , byOrder          = require('es5-ext/lib/Object/compare-by')('order').call
  , map2Array        = require('es5-ext/lib/Object/map-to-array').call
  , v                = require('es5-ext/lib/Object/descriptors/v')
  , count            = require('es5-ext/lib/Object/plain/count').call
  , oForEach         = require('es5-ext/lib/Object/plain/for-each').call
  , values           = require('es5-ext/lib/Object/plain/values').call
  , isNumber         = require('es5-ext/lib/Number/is-number')
  , scontains        = require('es5-ext/lib/String/contains').call
  , isNumeric        = require('es5-ext/lib/String/is-numeric').call
  , isString         = require('es5-ext/lib/String/is-string')
  , compareBooleans  = require('es5-ext/lib/Boolean/compare').call
  , compareDates     = require('es5-ext/lib/Date/compare').call
  , compareStrings   = require('es5-ext/lib/String/locale-compare-insensitive').call
  , compareNumbers   = require('es5-ext/lib/Number/compare').call

  , validator        = require('./validator')

  , valueMap, compareMap, getSelectValue, controlMap, controlSearchMap
  , setControlValueMap, setTextControl, setFormValues, getControl, compareSelect
  , compareObjects, checkUnique, dateRe, datetimeRe, parseDateConstraint
  , searchSelect, searchValidateMap, numericValidate, searchBool
  , optionsValidate, textValidate, boolValidate;

dateRe     = /^\d{4}-\d{2}-\d{2}$/;
datetimeRe = /^(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2})$/;

getSelectValue = function (value) {
	return (value == null) ? value : this.options[value].label;
};

compareSelect = function (schema, a, b) {
	return compareStrings(schema.options[a[this]].label,
		schema.options[b[this]].label);
};

compareObjects = memoize(function (compare) {
	return function (schema, a, b) {
		if ((a[this]!= null) && (b[this] != null)) {
			return compare(a[this], b[this]);
		}
		return (a[this] != null) ? -1 : ((b[this] != null) ? 1 : 0);
	}
});

valueMap = {
	bool: function (value) {
		return (value == null) ? "" : (value ? "Yes" : "No");
	},
	date: function (date) {
		return date ? dateFormat(date) : '';
	},
	datetime: function (date) {
		return date ? datetimeFormat(date) : '';
	},
	email: i,
	number: Number,
	password: i,
	radio: getSelectValue,
	checkbox: function (value) {
		return value ? "Yes" : "No";
	},
	select: getSelectValue,
	memo: i,
	text: i,
	tel: i
};

compareMap = {
	bool: compareObjects(compareBooleans),
	date: compareObjects(compareDates),
	datetime: compareObjects(compareDates),
	email: compareObjects(compareStrings),
	number: compareObjects(compareNumbers),
	radio: compareSelect,
	checkbox: compareObjects(compareBooleans),
	select: compareSelect,
	memo: compareObjects(compareStrings),
	text: compareObjects(compareStrings),
	tel: compareObjects(compareStrings)
};

parseDateConstraint = function (data, isTime) {
	var date
	if (data == null) {
		return null;
	}
	if (isNumber(data)) {
		date = new Date();
		date.setDate(date[isTime ? 'getMinutes' : 'getDate']() + data);
		return dateFormat(date);
	} else {
		return dateFormat(data);
	}
};

controlMap = {
	bool: function (data) {
		return [label(input({ type: 'radio', name:  this.name,
			value: 'true', required: this.required,
			checked: (data[this.name] === true) }), " ", "Yes")(), " ",
			label(input({ type: 'radio', name:  this.name,
				value: 'false', required: this.required,
				checked: (data[this.name] === false) }), " ", "No")()];
	},
	date: function (data) {
		var min, max, date;
		min = parseDateConstraint(this.min);
		max = parseDateConstraint(this.max);
		return input({ type: 'date', name: this.name, min: min, max: max,
			value: data && data[this.name] && dateFormat(data[this.name]),
			required: this.required })();
	},
	datetime: function (data) {
		var min, max, date;
		min = parseDateConstraint(this.min, true);
		max = parseDateConstraint(this.max, true);
		return [input({ type: 'date', name: this.name + '.date',
			value: data && data[this.name] && dateFormat(data[this.name]),
			required: this.required, min: min, max: max })(), " ",
			input({ type: 'time', name: this.name + '.time',
				value: data && data[this.name] && timeFormat(data[this.name]),
				required: this.required })()];
	},
	email: function (data) {
		return input({ type: 'email', name: this.name, autocorrect: 'off',
			autocapitalize: 'off', value: data && data[this.name],
			required: this.required })();
	},
	number: function (data) {
		return input({ type: 'number', name: this.name, min: this.min,
			max: this.max, step: this.step, value: data && data[this.name],
			required: this.required })();
	},
	password: function (data) {
		return input({ type: 'password', name: this.name,
			value: data && data[this.name], required: this.required,
			pattern: (this.pattern && this.pattern.source &&
				this.pattern.source.slice(1, -1)) })();
	},
	checkbox: function (data) {
		return input({ type: 'checkbox', name: this.name,
			checked: data && data[this.name] })();
	},
	radio: function (data) {
		return map2Array(this.options, function (meta, value) {
			return label(input({ type: 'radio', name: this.name, value: value,
				checked: value === (data && data[this.name]), required: this.required }),
				" ", meta.label)();
		}, this, byOrder).reduce(function (a, b) {
			return [].concat(a, " ", b);
		});
	},
	select: function (data) {
		return select({ name: this.name, required: this.required },
			this.required ? null : option(),
			map2Array(this.options, function (meta, name) {
				return option({ value: name,
					selected: name === (data && data[this.name]) }, meta.label);
			}, this, byOrder))();
	},
	text: function (data) {
		return input({ type: 'text', name: this.name,
			value: data && data[this.name], required: this.required,
			pattern: (this.pattern && this.pattern.source &&
				this.pattern.source.slice(1, -1)) })();
	},
	memo: function (data) {
		return textarea({ name: this.name, required: this.required },
			data && data[this.name])();
	},
	tel: function (data) {
		return input({ type: 'tel', name: this.name,
			value: data && data[this.name], required: this.required,
			pattern: (this.pattern && this.pattern.source &&
				this.pattern.source.slice(1, -1)) })();
	}
};

controlSearchMap = {
	bool: searchBool = function (data) {
		return select({ name: this.name },
			option(), option({ value: 'true' }, "Yes"),
			option({ value: 'false' }, "No"))();
	},
	date: function (data) {
		var min, max;
		min = parseDateConstraint(this.min);
		max = parseDateConstraint(this.max);
		return [label("from ", input({ type: 'date', name: this.name + '[min]',
			min: min, max: max })), " ",
		label("to ", input({ type: 'date', name: this.name + '[max]',
			min: min, max: max }))];
	},
	datetime: function (data) {
		var min, max;
		min = parseDateConstraint(this.min, true);
		max = parseDateConstraint(this.max, true);
		return [label("from ", input({ type: 'date', name: this.name + '.date[min]',
			min: min, max: max })), " ",
			input({ type: 'time', name: this.name + '.time[min]' }), " ",
			label("to ", input({ type: 'date', name: this.name + '.date[max]',
				min: min, max: max })), " ",
			input({ type: 'time', name: this.name + '.time[max]' })];
	},
	email: function (data) {
		return input({ type: 'text', name: this.name, autocorrect: 'off',
			autocapitalize: 'off'  })();
	},
	number: function (data) {
		return [label("from ", input({ type: 'number', name: this.name + '[min]',
			min: this.min, max: this.max, step: this.step })), " ",
			label(" to ", input({ type: 'number', name: this.name + '[max]',
				min: this.min, max: this.max, step: this.step }))];
	},
	checkbox: searchBool,
	radio: searchSelect = function (data) {
		var multiple = (count(this.options) > 2);
		return select({ name: this.name, multiple: multiple },
			multiple ? null : option(),
			map2Array(this.options, function (meta, name) {
				return option({ value: name }, meta.label);
			}, this, byOrder))();
	},
	select: searchSelect,
	text: function (data) {
		return input({ type: 'text', name: this.name  })();
	},
	memo: function (data) {
		return input({ type: 'text', name: this.name  })();
	},
	tel: function (data) {
		return input({ type: 'text', name: this.name  })();
	}
};

searchValidateMap = {
	bool: boolValidate = function (value) {
		if (!this && !this.toString()) {
			return true;
		}
		if (value == null) {
			return false;
		}
		return (this == 'true') ? value : !value;
	},
	date: numericValidate = function (value) {
		if (!this || !this.toString()) {
			return true;
		}
		if (!value) {
			return false;
		}
		if (this.min && (value < this.min)) {
			return false;
		}
		if (this.max && (value > this.max)) {
			return false;
		}
		return true;
	},
	datetime: numericValidate,
	email: function (value) {
		if (!this || !this.toString()) {
			return true;
		}
		if (!value) {
			return false;
		}
		return scontains(this, '@') ? (value.toLowerCase() == this) :
			scontains(value.toLowerCase(), this);
	},
	number: numericValidate,
	checkbox: boolValidate,
	radio: optionsValidate = function (value) {
		if (!this && !this.toString()) {
			return true;
		}
		if (!value) {
			return false;
		}
		if (isArray(this)) {
			return contains(this, value);
		} else {
			return (this == value);
		}
	},
	select: optionsValidate,
	text: textValidate = function (value) {
		if (!this && !this.toString()) {
			return true;
		}
		if (!value) {
			return false;
		}
		return scontains(value.toLowerCase(), this);
	},
	memo: textValidate,
	tel: textValidate
};

getControl = function (form, name) {
	var col;
	if (isNumeric(name)) {
		col = form.querySelectorAll('[name="' + name + '"]');
		return (col.length > 1) ? col : col[0];
	} else {
		return form[name];
	}
};

setControlValueMap = {
	bool: function (form, data) {
		var value, control;
		control = getControl(form, this.name);
		if (!control || !control.length) {
			return;
		}
		value = data[this.name];
		if (value === true) {
			control[0].setAttribute('checked', 'checked');
			control[0].checked = true;
			control[1].removeAttribute('checked');
			control[1].checked = false;
		} else if (value === false) {
			control[1].setAttribute('checked', 'checked');
			control[1].checked = true;
			control[0].removeAttribute('checked');
			control[0].checked = false;
		} else {
			control[0].removeAttribute('checked');
			control[0].checked = false;
			control[1].removeAttribute('checked');
			control[1].checked = false;
		}
	},
	checkbox: function (form, data) {
		var value, control;
		control = getControl(form, this.name);
		if (!control) {
			return;
		}
		value = data[this.name];

		if (value === true) {
			control.setAttribute('checked', 'checked');
			control.checked = true;
		} else if (value === false) {
			control.removeAttribute('checked');
			control.checked = false;
		}
	},
	date: function (form, data) {
		var value, control;
		control = getControl(form, this.name);
		if (!control) {
			return;
		}
		if (data[this.name]) {
			value = dateFormat(data[this.name]);
			control.setAttribute('value', value);
			control.value = value;
		} else {
			control.removeAttribute('value');
			control.value = '';
		}
	},
	datetime: function (form, data) {
		var value, dcontrol, tcontrol, cvalue;
		dcontrol = getControl(form, this.name + '.date');
		tcontrol = getControl(form, this.name + '.time');
		if (!dcontrol || !tcontrol) {
			return;
		}
		value = data[this.name];
		if (value == null) {
			dcontrol.removeAttribute('value');
			dcontrol.value = "";
			tcontrol.removeAttribute('value');
			tcontrol.value = "";
		} else {
			cvalue = dateFormat(value);
			dcontrol.setAttribute('value', cvalue);
			dcontrol.value = cvalue;

			cvalue = timeFormat(value);
			tcontrol.setAttribute('value', cvalue);
			tcontrol.value = cvalue;
		}
	},
	email: setTextControl = function (form, data) {
		var value, control;
		control = getControl(form, this.name);
		if (!control) {
			return;
		}
		value = data[this.name];
		if (value == null) {
			control.removeAttribute('value');
			control.value = "";
		} else {
			control.setAttribute('value', value);
			control.value = value;
		}
	},
	memo: function (form, data) {
		var value, control;
		control = getControl(form, this.name);
		if (!control) {
			return;
		}
		if (!control.firstChild) {
			control.appendChild(document.createTextNode(""));
		}
		value = data[this.name];
		if (value == null) {
			control.firstChild.data = "";
			control.value = "";
		} else {
			control.firstChild.data = value;
			control.value = value;
		}
	},
	number: setTextControl,
	password: setTextControl,
	radio: function (form, data) {
		var value, control;
		control = getControl(form, this.name);
		if (!control || !control.length) {
			return;
		}
		value = data[this.name];
		forEach(control, function (radio) {
			if (radio.value === value) {
				radio.setAttribute('checked', 'checked');
				radio.checked = true;
			} else if (radio.hasAttribute('checked')) {
				radio.removeAttribute('checked');
			}
		});
	},
	select: function (form, data) {
		var value, control, selected, old;
		control = getControl(form, this.name);
		if (!control) {
			return;
		}
		value = data[this.name];
		selected = control.querySelector('option[value="' + value + '"]');
		old = control.querySelector('option[selected]');
		if (selected !== old) {
			if (selected) {
				selected.setAttribute('selected', 'selected');
			}
			if (old) {
				old.removeAttribute('selected');
			}
		}
		control.value = value;
	},
	text: setTextControl,
	tel: setTextControl
};

setFormValues = v(function (form, data) {
	values(this).forEach(function (value) {
		if (value.setControlValue) {
			value.setControlValue(form, data);
		}
	});
});

checkUnique = function (schema, meta, validate) {
	var isUnique = validator._unique.bind(schema, meta);
	return function (value, data, obj) {
		return validate(value, data) || isUnique(value, data, obj);
	};
};

exports = module.exports = function (schema) {
	var match;
	oForEach(schema, function (value, name) {
		if (isString(value)) {
			schema[name] = value = { type: value };
		}
		if (value.type == null) {
			value.type = 'text';
		}
		value.name = name;
		if (valueMap[value.type]) {
			value.toString = valueMap[value.type];
		}
		if (controlMap[value.type]) {
			value.buildControl = controlMap[value.type];
			value.setControlValue = setControlValueMap[value.type];
		}
		if (controlSearchMap[value.type]) {
			value.buildSearchControl = controlSearchMap[value.type];
			value.validateSearch = searchValidateMap[value.type];
		}
		if (!value.compare && compareMap[value.type]) {
			value.compare = compareMap[value.type].bind(name, value);
		}
		if (!value.validate) {
			value.validate = isString(value.type) ?
				validator[value.type].bind(schema, value) :
				validator._ns.bind(schema, value);
		}
		if (value.unique) {
			value.validate = checkUnique(schema, value, value.validate);
		}
		if (value.type == 'text') {
			if (isString(value.pattern)) {
				try {
					value.pattern = new RegExp('^' + value.pattern + '$');
				} catch (e) {
					console.error("Schema error: invalid pattern: '" +
						value.pattern + "'");
					delete value.pattern;
				}
			}
		}
		if (value.type === 'date') {
			if (isString(value.min) && value.min.match(dateRe)) {
				value.min = new Date(Date.parse(value.min));
			}
			if (isString(value.max) && value.max.match(dateRe)) {
				value.max = new Date(Date.parse(value.max));
			}
		}
		if (value.type === 'datetime') {
			if (isString(value.min) && (match = value.min.match(datetimeRe))) {
				value.min = new Date(Date.parse(match[1] + 'T' + match[2] + 'Z'));
				value.min.setMinutes(value.min.getMinutes() +
					value.min.getTimezoneOffset());
			}
			if (isString(value.max) && (match = value.max.match(datetimeRe))) {
				value.max = new Date(Date.parse(match[1] + 'T' + match[2] + 'Z'));
				value.max.setMinutes(value.max.getMinutes() +
					value.max.getTimezoneOffset());
			}
		}
	});
	return defineProperties(schema, {
		_ordered: v(values(schema).sort(byOrder)),
		_setFormValues: setFormValues
	});
};

exports.setDynamic = function (schema) {
	return defineProperty(schema, '__dynamic', v(true));
};

exports.controlMap = controlMap;
exports.setControlValueMap = setControlValueMap;
exports.controlSearchMap = controlSearchMap;
exports.searchValidateMap = searchValidateMap;
exports.compareMap = compareMap;

exports.getControl = getControl;
