'use strict';

var isArray          = Array.isArray
  , create           = Object.create
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , keys             = Object.keys
  , push             = require('es5-ext/lib/Array/push/apply')
  , dateCompare      = require('es5-ext/lib/Date/compare').bind
  , invoke           = require('es5-ext/lib/Function/invoke')
  , isFunction       = require('es5-ext/lib/Function/is-function')
  , noop             = require('es5-ext/lib/Function/noop')
  , pluck            = require('es5-ext/lib/Function/pluck')
  , aritize          = require('es5-ext/lib/Function/aritize').call
  , lock             = require('es5-ext/lib/Function/lock').call
  , sequence         = require('es5-ext/lib/Function/sequence').call
  , contains         = require('es5-ext/lib/List/contains').call
  , diff             = require('es5-ext/lib/List/diff').call
  , searchHighest    = require('es5-ext/lib/List/sorted/binary-boundary-search')(true, true)
  , searchLowest     = require('es5-ext/lib/List/sorted/binary-boundary-search')(true)
  , extend           = require('es5-ext/lib/Object/extend').call
  , c                = aritize(require('es5-ext/lib/Object/descriptors/c'), 1)
  , e                = require('es5-ext/lib/Object/descriptors/e')
  , v                = require('es5-ext/lib/Object/descriptors/v')
  , createp          = require('es5-ext/lib/Object/plain/create')
  , empty            = require('es5-ext/lib/Object/plain/empty').call
  , get              = require('es5-ext/lib/Object/plain/get')
  , getLength        = require('es5-ext/lib/Object/plain/get-length').call
  , oForEach         = require('es5-ext/lib/Object/plain/for-each').call
  , oMap             = require('es5-ext/lib/Object/plain/map').call
  , merge            = require('es5-ext/lib/Object/plain/merge').call
  , setTrue          = require('es5-ext/lib/Object/plain/set-value').curry(true)
  , ee               = require('event-emitter')

  , list             = require('./list')

  , index, indexes, filter, filters, filterFactory;

indexes = {
	date: function (f, name) {
		return f.data.list(name);
	},
	select: {
		init: function (f, name) {
			this.name = name;
			this.data = oMap(f.ns.schema[name].options, lock(Object));
			oForEach(f.data, this.onadd, this);
			return f.uindexes[name] = this;
		},
		onadd: function (obj) {
			this.data[obj[this.name]][obj._id] = obj;
		},
		onremove: function (obj, old) {
			delete this.data[old[this.name]][obj._id];
		},
		onupdate: function (obj, old) {
			delete this.data[old[this.name]][obj._id];
			this.data[obj[this.name]][obj._id] = obj;
		}
	}
};

filter = ee(defineProperties({}, {
	init: v(function (parent, name) {
		return defineProperties(this, {
			parent: v(parent),
			ns: v(parent.ns),
			name: v(name),
			lists: v({ methods: [], lists: [] }),
			length: c(0)
		});
	}),
	onadd: v(function (obj) {
		if (this.isValid(obj)) {
			this[obj._id] = obj;
			defineProperty(this, 'length', c(this.length + 1));
			this.emit('add', obj);
		}
	}),
	onremove: v(function (obj, old) {
		if (this[obj._id]) {
			delete this[obj._id];
			defineProperty(this, 'length', c(this.length - 1));
			this.emit('remove', obj, old);
		}
	}),
	onupdate: v(function (obj, old) {
		if (this.isValid(obj)) {
			if (!this[obj._id]) {
				this[obj._id] = obj;
				defineProperty(this, 'length', c(this.length + 1));
				this.emit('add', obj);
			}
		} else if (this[obj._id]) {
			delete this[obj._id];
			defineProperty(this, 'length', c(this.length - 1));
			this.emit('remove', obj, old);
		}
	}),
	list: e(function (sortMethod) {
		var index, l;
		if ((index = this.lists.methods.indexOf(sortMethod)) !== -1) {
			return this.lists.lists[index];
		}
		l = list(this, sortMethod);
		this.lists.methods.push(sortMethod);
		this.lists.lists.push(l);
		return l;
	}),
	destroy: e(function () {
		var pf = this.parent.filters[this.name];
		pf.splice(pf.indexOf(this), 1);
		empty(this);
		this.allOff();
		defineProperty(this, 'length', c(0));
		this.emit('destroy');
	})
}), true);


filters = {
	_notIndexed: extend(filter, {
		init: v(function (_super, cond, parent, name) {
			var length = 0;
			_super(this, parent, name || '');
			defineProperty(this, 'cond', v(cond));
			oForEach(parent.data, function (obj) {
				if (this.isValid(obj)) {
					this[obj._id] = obj;
					++length;
				}
			}, this);
			return defineProperty(this, 'length', c(length));
		}),
		isValid: v(function (obj) {
			return this.cond(this.name ? obj[this.name] : obj, obj)
		})
	}),
	date: extend(filter, {
		keys: v(['min', 'max']),
		init: v(function (_super, index, parent, name) {
			var bounds, list;
			_super(this, parent, name);
			defineProperty(this, 'index', v(index));
			index.sort();
			bounds = this.getBoundaries();
			list = index.slice(bounds[0], bounds[1]);
			list.forEach(function (obj) {
				this[obj._id] = obj;
			}, this);
			return defineProperty(this, 'length', c(list.length));
		}),
		getBoundaries: v(function () {
			var start, end, compare, fn;
			compare = dateCompare(this.min);
			fn = function (i) {
				return compare(this.index[i][this.name]);
			}.bind(this);
			start = this.min ? searchLowest(fn, this.index.length) : 0;

			compare = dateCompare(this.max);
			end = this.max ? searchHighest(fn, this.index.length) + 1 :
				this.index.length;
			return [start, end];
		}),
		update: e(function (min, max) {
			var bounds, n, o;
			defineProperties(this, {
				min: c(min),
				max: c(max)
			});

			this.index.sort();
			bounds = this.getBoundaries();
			n = this.index.slice(bounds[0], bounds[1]).map(pluck('_id'));
			o = keys(this);
			diff(o, n).forEach(sequence(get, this.onremove), this);
			diff(n, o).forEach(sequence(get, this.onadd.bind(this)),
				this.parent.data);
			defineProperty(this, 'length', c(n.length));
		}),
		isValid: v(function (obj) {
			var value = obj[this.name].getTime();
			return ((!this.min || (this.min < value)) &&
				(!this.max || (this.max > value)));
		})
	}),
	select: extend(filter, {
		keys: v(['select']),
		init: v(function (_super, index, parent, name) {
			_super(this, parent, name);
			defineProperty(this, 'index', v(index));
			this.setSelect(this.select);
			keys(this.select).forEach(function (name) {
				merge(this, this.index.data[name]);
			}, this);
			return defineProperty(this, 'length', c(getLength(this)));
		}),
		isValid: v(function (obj) {
			return this.select.hasOwnProperty(obj[this.name]);
		}),
		setSelect: v(function (select) {
			var hash = {}
			if (isArray(select)) {
				select.forEach(setTrue, hash);
			} else {
				hash[select] = true;
			}
			defineProperty(this, 'select', c(hash));
		}),
		update: e(function (select) {
			var n, o;
			this.setSelect(select);
			n = [];
			keys(this.select).forEach(function (name) {
				push(n, keys(this.index.data[name]));
			}, this);

			o = keys(this);
			diff(o, n).forEach(sequence(get, this.onremove), this);
			diff(n, o).forEach(sequence(get, this.onadd.bind(this)),
				this.parent.data);
			defineProperty(this, 'length', c(n.length));
		})
	})
};

filterFactory = {
	onadd: function (obj) {
		var fn = invoke('onadd', obj);
		oForEach(this.uindexes, fn);
		oForEach(this.filters, invoke('forEach', fn));
		obj._on('update', this.onupdate);
	},
	onremove: function (obj, old) {
		var fn = invoke('onremove', obj, old);
		oForEach(this.uindexes, fn);
		oForEach(this.filters, invoke('forEach', fn));
		if (!obj._destroyed) {
			obj._off('update', this.onupdate);
		}
	},
	onupdate: function (changed, old, obj) {
		changed.forEach(function (name) {
			if (this.uindexes[name]) {
				this.uindexes[name].onupdate(obj, old);
			}
			if (this.filters[name]) {
				this.filters[name].forEach(invoke('onupdate', obj, old));
			}
		}, this);
		if (this.filters['']) {
			this.filters[''].forEach(invoke('onupdate', obj, old));
		}
	},
	filter: function (name, cond) {
		var filter, proto, invalid;
		if (isFunction(name)) {
			if (!this.filters['']) {
				this.filters[''] = [];
			}
			this.filters[''].push(filter =
				create(filters._notIndexed).init(name, this));
		} else {
			if (!this.filters[name]) {
				this.filters[name] = [];
			}
			if (isFunction(cond)) {
				this.filters[name].push(filter =
					create(filters._notIndexed).init(cond, this, name));
			} else {
				if (!this.indexes[name]) {
					console.log(name, cond);
					throw new Error("Field not scheduled for indexing");
				}
				proto = filters[this.ns.schema[name].type];
				if ((invalid = diff(keys(cond), proto.keys)).length) {
					console.log(invalid, proto);
					throw new Error("Invalid rules for filter");
				}
				this.filters[name].push(filter =
					create(proto, oMap(cond, c)).init(this.indexes[name], this, name));
			}
		}
		return filter;
	}
};

module.exports = function (data, ns) {
	var f = createp(filterFactory, {
		indexes: {},
		uindexes: {},
		filters: {},
		data: data,
		ns: ns
	});
	f.onupdate = f.onupdate.bind(f);
	oForEach(ns.schema, function (value, name) {
		if (value.filtered) {
			f.indexes[name] = isFunction(indexes[value.type]) ?
				indexes[value.type](f, name) :
				createp(indexes[value.type]).init(f, name);
		}
	});
	data.on('add', f.onadd.bind(f));
	data.on('remove', f.onremove.bind(f));
	oForEach(data, function (obj) {
		obj._on('update', this);
	}, f.onupdate);
	return f;
};
