'use strict';

var dparse       = Date.parse
  , stringify    = JSON.stringify
  , fs           = require('fs')
  , http         = require('http')
  , path         = require('path')
  , parse        = require('url').parse
  , m2a          = require('es5-ext/lib/Object/map-to-array').call
  , startsWith   = require('es5-ext/lib/String/starts-with').call
  , format       = require('es5-ext/lib/Date/format')('%m-%d %H:%M:%S').call
  , a2p          = require('deferred/lib/async-to-promise').call
  , ba2p         = require('deferred/lib/async-to-promise').bind
  , buildClient  = require('./build-client')
  , config       = require('../../../config')

  , readFile = ba2p(fs.readFile), stat = ba2p(fs.stat)
  , createReadStream = fs.createReadStream
  , extname = path.extname, dirname = path.dirname, basename = path.basename

  , mime = require('./mime')
  , urlTest = /^\/(?:[jci]\/.*|favicon.ico|offline.appcache)$/

  , root = dirname(dirname(dirname(__dirname)))
  , publicPath = root + '/public'
  , name = 'main';

module.exports = function (port) {
	var server, index, modified = {}, imDate = new Date();
	console.log("SETUP", port);

	// Read main html
	index = readFile(publicPath + '/' + name + '.html', 'utf-8')
	(function (content) {
		if (config.OFFLINE) {
			content = content.replace('<html>',
				'<html manifest="/offline.appcache">');
		}
		return content.replace('$OFFLINE_MODE', config.OFFLINE ? 'ON' : 'OFF')
			.replace('$SERVER_VER', format(new Date()));
	}).end();

	// get build JS function
	buildClient = ba2p(buildClient(root + '/lib'));

	// setup server
	server = require('http').createServer(function (req, res) {
		if (server.ext.some(function (fn) {
			return fn(req, res);
		})) {
			return;
		}
		var url = parse(req.url).pathname, ext, headers, s, match;
		if (url && url.match(urlTest)) {
			// static
			if (config.JS_DEVEL && (url === '/j/' + name + '.js')) {
				// Build JS on the go
				res.writeHead(200, { 'Content-Type':
					'application/javascript; charset=utf-8',
					'Cache-Control': 'no-cache' });
				buildClient()(function (content) {
					res.end(content);
				}, function (err) {
					res.end('document.write(\'<p style="font-size: 2em; padding: 2em;'
						+ ' text-align: center; font-weight: bold; color: red">Could'
						+ ' not generate main.js: ' +
						err.message.replace(/'/g, '\\\'') + '</p>\');');
				}).end();
				return;
			}
			if ((url === '/offline.appcache') && !config.OFFLINE) {
				res.writeHead(404, 'Not Found');
				res.end();
			} else {
				((config.OFFLINE && modified[url]) || (modified[url] = stat(publicPath + url)
					(function (stat) {
						return new Date(Date.parse(stat.mtime));
					})))
				(function (mdate) {
					if (req.headers['if-modified-since'] &&
						 (mdate <= new Date(req.headers['if-modified-since']))) {
						console.log("NOT MODIFIED", url);
						res.writeHead(304, 'Not Modified');
						res.end();
					} else {
						console.log("!MODIFIED", url, req.headers['if-modified-since']);
						s = createReadStream(publicPath + url);
						s.on('error', function () {
							res.writeHead(404);
							res.end('404 Not Found');
						});
						headers = {};
						s.once('data', function () {
							ext = extname(url).slice(1);
							headers['Content-Type'] = mime.mime[ext] || mime.mime[''];
							if (mime.charset[ext]) {
								headers['Content-Type'] += '; charset=' + mime.charset[ext];
							}
							if ((url === '/offline.appcache') || startsWith(url, '/j/')) {
								headers['Cache-Control'] = 'no-cache';
							} else {
								headers['Last-Modified'] = mdate.toString();
							}
							res.writeHead(200, headers);
						});
						s.pipe(res);
					}
				}, function () {
					res.writeHead(404, 'Not Found');
					res.end();
				}).end();
			}
		} else {
			if (req.headers['if-modified-since'] &&
				 (imDate <= new Date(req.headers['if-modified-since']))) {
				console.log("NOT MODIFIED INDEX", url);
				res.writeHead(304, 'Not Modified');
				res.end();
			} else {
				console.log("!MODIFIED INDEX", url);
				res.writeHead(200, {'Content-Type': 'text/html; charset=utf8',
					'Last-Modified': imDate.toString() });
				index(res.end.bind(res));
			}
		}
	});

	server.listen(port);
	server.ext = [];
	return server;
};
